/*
 * МНОГОПОТОЧНЫЙ ПОДСЧЕТ ПРОСТЫХ ЧИСЕЛ
 * 
 * ОПИСАНИЕ:
 * Эта программа демонстрирует базовые принципы многопоточного программирования.
 * Она находит количество простых чисел в заданном диапазоне, распределяя работу между несколькими потоками.
 * 
 * КЛЮЧЕВЫЕ МОМЕНТЫ ДЛЯ ИЗУЧЕНИЯ:
 * 1. Разделение большой задачи на независимые части (декомпозиция)
 * 2. Использование std::async для создания асинхронных задач
 * 3. Работа с future для получения результатов из потоков
 * 4. Измерение производительности параллельных вычислений
 * 
 * ВЫВОДЫ:
 * - Многопоточность эффективна для задач, которые можно разделить на независимые части
 * - Количество потоков должно соответствовать возможностям процессора
 * - Накладные расходы на создание потоков нужно учитывать при малых объемах данных
 * 
 * ЗАПУСК ПРОГРАММЫ:
 * program.exe N threads
 * где: N - верхняя граница диапазона
 *      threads - количество потоков (необязательно)
 * 
 * Пример: ./count_primes 1000000 4
 */

#include <algorithm>    // для работы с алгоритмами (min, transform_reduce и др.)
#include <chrono>       // для измерения времени выполнения
#include <cstdlib>      // для работы с функциями стандартной библиотеки (EXIT_FAILURE)
#include <future>       // для асинхронного выполнения задач (async, future)
#include <iostream>     // для ввода-вывода
#include <numeric>      // для численных операций
#include <vector>       // для работы с динамическими массивами
#include <string>       // для работы со строками

bool is_prime(int n) { // Функция проверяет, является ли число простым
    if (n < 2) { // Если число меньше 2, оно не является простым
        return false;
    }

    for (int i = 2; i < n; ++i) { // Перебираем числа от 2 до n-1
        if (n % i == 0) { // Если n делится на i без остатка
            return false; // То число не простое
        }
    }
    return true; // Если нет делителей, число простое
}

int count_primes(int begin, int end) { // Функция считает количество простых чисел в диапазоне [begin, end)
    int count = 0; // Инициализируем счетчик простых чисел
    while (begin != end) { // Пока не достигнут конец диапазона
        count += is_prime(begin++); // Увеличиваем счетчик, если текущее число простое
    }
    return count; // Возвращаем количество найденных простых чисел
}

int main(int argc, char *argv[]) { // Главная функция программы с аргументами командной строки
    using namespace std; // Используем пространство имен std
    if (argc < 2) { // Если передано меньше 2 аргументов
        cout << "Usage: " << argv[0] << " n [nthreads]\n"; // Выводим инструкцию по использованию
        return EXIT_FAILURE; // Завершаем программу с ошибкой
    }
    int n = stoi(argv[1]); // Преобразуем первый аргумент в число
    if (n <= 0) { // Проверяем, что число положительное
        cerr << "n must be positive number\n"; // Выводим сообщение об ошибке
        return EXIT_FAILURE; // Завершаем программу с ошибкой
    }
    int n_threads = (argc > 2) ? stoi(argv[2]) : thread::hardware_concurrency(); // Определяем количество потоков
    if (n_threads < 1) { // Проверяем корректность количества потоков
        cerr << "nthreads must be positive number\n"; // Выводим сообщение об ошибке
        return EXIT_FAILURE; // Завершаем программу с ошибкой
    }

    int batch_size = n / n_threads; // Вычисляем размер порции чисел для каждого потока
    vector<future<int>> tasks; // Создаем вектор для хранения результатов асинхронных задач
    chrono::time_point start = chrono::high_resolution_clock::now(); // Засекаем время начала вычислений

    for (int i = 2; i < n; i += batch_size) { // Распределяем работу между потоками
        tasks.emplace_back(async(std::launch::async, count_primes, i, // Запускаем асинхронную задачу
                                 std::min(n, i + batch_size))); // Определяем границы порции для потока
    }

    size_t nprimes = // Подсчитываем общее количество простых чисел
        transform_reduce(tasks.begin(), tasks.end(), 0, plus<int>{}, // Суммируем результаты всех потоков
                         [](auto &result) { return result.get(); }); // Получаем результат каждой задачи
    chrono::time_point end = chrono::high_resolution_clock::now(); // Засекаем время окончания вычислений
    chrono::duration<double> elapsed = end - start; // Вычисляем затраченное время
    cout << nprimes << '\n'; // Выводим количество найденных простых чисел
    cout << "It tooks " << elapsed.count() << " seconds with " << n_threads // Выводим время выполнения
         << " threads\n"; // и количество использованных потоков
}

