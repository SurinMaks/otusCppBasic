/*
* Распространённая ошибка при работе с потоками в C++.
* Программа пытается записать большой объём данных (40МБ) в "пустое" устройство в фоновом режиме.
* 
* ПРОБЛЕМЫ КОДА:
* 1. Использование detach() вместо join() может привести к тому, что основная программа
*    завершится до того, как фоновый поток закончит работу
* 2. Нет обработки ошибок при работе с файлами
* 3. Небезопасная передача параметров в поток
* 
* ВЫВОДЫ:
* 1. Всегда используйте join() когда нужно дождаться завершения потока
* 2. Обрабатывайте ошибки при работе с файлами и потоками
* 3. Будьте внимательны при передаче данных между потоками
* 4. Помните о "гонке за ресурсами" (race condition) при работе с потоками
*/


#include <cstddef>  // Для работы с типами данных размеров и указателей
#include <fstream>  // Для работы с файлами (ofstream)
#include <iostream> // Для ввода-вывода (clog, getchar)
#include <iterator> // Для работы с итераторами
#include <ostream>  // Для работы с потоками вывода
#include <thread>   // Для многопоточного программирования
#include <vector>   // Для работы с динамическими массивами

// Определяем путь к "пустому" устройству в зависимости от операционной системы
#if defined(__linux__) || defined(__APPLE__) // Если Linux или MacOS
const char *null = "/dev/null";              // Используем Unix-путь к null-устройству
#elif defined(_WIN32)                        // Если Windows
const char *null = "NUL";                    // Используем Windows-путь к null-устройству
#else                                        // Если другая ОС
#error platform not supportedd               // Выдаём ошибку компиляции
#endif

// Функция создаёт и возвращает поток для записи файла в фоновом режиме
std::thread savefile_bg(const std::string &filename) { // Принимает имя файла по ссылке
   return std::thread(                                 // Создаём и возвращаем новый поток
       [](const std::string filename) {                // Лямбда-функция, копирует имя файла
           std::vector<char> buffer(10 * 4096 * 4096, 'A'); // Создаём буфер ~40MB, заполненный символами 'A'
           std::ofstream out(filename);                // Открываем файл для записи
           out.write(buffer.data(), buffer.size());    // Записываем весь буфер в файл
           out.close();                                // Закрываем файл
           std::clog << "File written\n";              // Выводим сообщение об успешной записи
       },
       filename);                                      // Передаём имя файла в лямбда-функцию
}

int main() {
   std::thread bg_task = savefile_bg(null); // Создаём фоновую задачу записи в null-устройство
   bg_task.detach();                        // Отсоединяем поток (он продолжит работу независимо)
   std::getchar();                          // Ждём нажатия клавиши перед завершением программы
}