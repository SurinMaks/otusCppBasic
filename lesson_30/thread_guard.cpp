// Создаём обёртку для потока для автоматического управления жизненным циклом потока

#include <thread> // Подключаем библиотеку для работы с потоками

// Класс-обёртка для автоматического присоединения потока при выходе из области видимости
class thread_guard {
public:
   thread_guard(std::thread &thread) // Конструктор принимает ссылку на поток
       : thread_{thread} // Инициализируем ссылку на поток через список инициализации
   {}

   thread_guard(const thread_guard&) = delete; // Запрещаем копирование объектов (нельзя скопировать поток)

   thread_guard& operator=(const thread_guard&) = delete; // Запрещаем присваивание объектов
   
   ~thread_guard() { // Деструктор - вызывается автоматически при уничтожении объекта
       if (thread_.joinable()) { // Проверяем, можно ли присоединить поток
           thread_.join(); // Если да - присоединяем поток (ждём его завершения)
       }
   }
private:
   std::thread &thread_; // Хранимая ссылка на поток (& означает что это ссылка, а не копия)
};

void foo() {} // Пустая функция, которую будем выполнять в отдельном потоке

int main() {
   std::thread th{foo}; // Создаём новый поток, выполняющий функцию foo
   thread_guard guard{th}; // Создаём охранный объект - он автоматически присоединит поток при выходе из main
} // Здесь вызывается деструктор guard, который дождётся завершения потока